const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

/**
 * Automated Vulnerability Scanner
 * Scans codebase for common security vulnerabilities
 */

class VulnerabilityScanner {
  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.vulnerabilities = [];
    this.scannedFiles = 0;
    this.patterns = this.loadSecurityPatterns();
  }

  loadSecurityPatterns() {
    return {
      // SQL Injection patterns
      sqlInjection: [
        /query\s*\+\s*['"]/gi,
        /\$\{.*\}/g, // Template literals in queries
        /['"].*\+.*['"]/g, // String concatenation
        /exec\s*\(/gi,
        /eval\s*\(/gi
      ],

      // XSS patterns
      xss: [
        /innerHTML\s*=/gi,
        /document\.write\s*\(/gi,
        /\.html\s*\(/gi,
        /dangerouslySetInnerHTML/gi
      ],

      // Authentication issues
      authentication: [
        /password.*=.*['"]/gi,
        /secret.*=.*['"]/gi,
        /token.*=.*['"]/gi,
        /api[_-]?key.*=.*['"]/gi
      ],

      // Insecure cryptography
      cryptography: [
        /md5\s*\(/gi,
        /sha1\s*\(/gi,
        /Math\.random\s*\(/gi, // Weak random number generation
        /crypto\.createHash\s*\(\s*['"]md5['"]/gi
      ],

      // Path traversal
      pathTraversal: [
        /\.\.\//g,
        /path\.join\s*\(.*\.\./gi,
        /fs\.readFile\s*\(.*\+/gi
      ],

      // Command injection
      commandInjection: [
        /exec\s*\(/gi,
        /spawn\s*\(/gi,
        /system\s*\(/gi,
        /shell_exec/gi
      ],

      // Information disclosure
      informationDisclosure: [
        /console\.log\s*\(/gi,
        /console\.error\s*\(/gi,
        /printStackTrace/gi,
        /\.stack/gi
      ],

      // Insecure dependencies
      insecureDependencies: [
        /"express":\s*"[^4]/gi, // Old Express versions
        /"mongoose":\s*"[^6]/gi, // Old Mongoose versions
        /"jsonwebtoken":\s*"[^8]/gi // Old JWT versions
      ]
    };
  }

  async scanProject() {
    console.log('🔍 Starting vulnerability scan...');
    
    await this.scanDirectory(this.projectRoot);
    await this.scanPackageFiles();
    await this.scanConfigFiles();
    
    return this.generateScanReport();
  }

  async scanDirectory(dirPath) {
    const entries = fs.readdirSync(dirPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);
      
      // Skip node_modules, .git, and other irrelevant directories
      if (entry.isDirectory() && !this.shouldSkipDirectory(entry.name)) {
        await this.scanDirectory(fullPath);
      } else if (entry.isFile() && this.shouldScanFile(entry.name)) {
        await this.scanFile(fullPath);
      }
    }
  }

  shouldSkipDirectory(dirName) {
    const skipDirs = ['node_modules', '.git', 'coverage', 'dist', 'build', '.next'];
    return skipDirs.includes(dirName);
  }

  shouldScanFile(fileName) {
    const extensions = ['.js', '.ts', '.jsx', '.tsx', '.json'];
    return extensions.some(ext => fileName.endsWith(ext));
  }

  async scanFile(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      this.scannedFiles++;
      
      const relativePath = path.relative(this.projectRoot, filePath);
      
      // Scan for each vulnerability type
      Object.entries(this.patterns).forEach(([category, patterns]) => {
        patterns.forEach((pattern, index) => {
          const matches = content.match(pattern);
          if (matches) {
            matches.forEach(match => {
              const lineNumber = this.getLineNumber(content, match);
              this.vulnerabilities.push({
                type: category,
                severity: this.getSeverity(category),
                file: relativePath,
                line: lineNumber,
                match: match.trim(),
                description: this.getDescription(category, match),
                recommendation: this.getRecommendation(category)
              });
            });
          }
        });
      });
      
    } catch (error) {
      console.warn(`Warning: Could not scan file ${filePath}: ${error.message}`);
    }
  }

  async scanPackageFiles() {
    const packagePath = path.join(this.projectRoot, 'package.json');
    if (fs.existsSync(packagePath)) {
      const packageContent = fs.readFileSync(packagePath, 'utf8');
      const packageJson = JSON.parse(packageContent);
      
      // Check for known vulnerable dependencies
      const vulnerableDeps = this.checkDependencies(packageJson.dependencies || {});
      const vulnerableDevDeps = this.checkDependencies(packageJson.devDependencies || {});
      
      [...vulnerableDeps, ...vulnerableDevDeps].forEach(vuln => {
        this.vulnerabilities.push({
          type: 'insecureDependencies',
          severity: 'medium',
          file: 'package.json',
          line: 0,
          match: `${vuln.name}@${vuln.version}`,
          description: `Potentially vulnerable dependency: ${vuln.name}`,
          recommendation: `Update ${vuln.name} to a secure version`
        });
      });
    }
  }

  checkDependencies(dependencies) {
    const vulnerableDeps = [];
    const knownVulnerabilities = {
      'express': { minSafe: '4.17.1', reason: 'Security vulnerabilities in older versions' },
      'mongoose': { minSafe: '6.0.0', reason: 'Security improvements in v6+' },
      'jsonwebtoken': { minSafe: '8.5.1', reason: 'Algorithm confusion vulnerabilities' },
      'lodash': { minSafe: '4.17.21', reason: 'Prototype pollution vulnerabilities' }
    };
    
    Object.entries(dependencies).forEach(([name, version]) => {
      if (knownVulnerabilities[name]) {
        const cleanVersion = version.replace(/[\^~]/, '');
        if (this.isVersionVulnerable(cleanVersion, knownVulnerabilities[name].minSafe)) {
          vulnerableDeps.push({
            name,
            version,
            reason: knownVulnerabilities[name].reason
          });
        }
      }
    });
    
    return vulnerableDeps;
  }

  isVersionVulnerable(currentVersion, minSafeVersion) {
    const current = currentVersion.split('.').map(Number);
    const minSafe = minSafeVersion.split('.').map(Number);
    
    for (let i = 0; i < Math.max(current.length, minSafe.length); i++) {
      const currentPart = current[i] || 0;
      const minSafePart = minSafe[i] || 0;
      
      if (currentPart < minSafePart) return true;
      if (currentPart > minSafePart) return false;
    }
    
    return false;
  }

  async scanConfigFiles() {
    const configFiles = [
      '.env',
      '.env.example',
      'config/default.js',
      'config/production.js'
    ];
    
    configFiles.forEach(configFile => {
      const configPath = path.join(this.projectRoot, configFile);
      if (fs.existsSync(configPath)) {
        const content = fs.readFileSync(configPath, 'utf8');
        
        // Check for hardcoded secrets
        const secretPatterns = [
          /password\s*=\s*['"]\w+['"]/gi,
          /secret\s*=\s*['"]\w+['"]/gi,
          /key\s*=\s*['"]\w+['"]/gi,
          /token\s*=\s*['"]\w+['"]/gi
        ];
        
        secretPatterns.forEach(pattern => {
          const matches = content.match(pattern);
          if (matches) {
            matches.forEach(match => {
              this.vulnerabilities.push({
                type: 'hardcodedSecrets',
                severity: 'high',
                file: configFile,
                line: this.getLineNumber(content, match),
                match: match.replace(/['"]\w+['"]/, '"***"'), // Mask the secret
                description: 'Hardcoded secret found in configuration',
                recommendation: 'Use environment variables for sensitive data'
              });
            });
          }
        });
      }
    });
  }

  getLineNumber(content, match) {
    const lines = content.substring(0, content.indexOf(match)).split('\n');
    return lines.length;
  }

  getSeverity(category) {
    const severityMap = {
      sqlInjection: 'critical',
      xss: 'high',
      authentication: 'high',
      cryptography: 'medium',
      pathTraversal: 'high',
      commandInjection: 'critical',
      informationDisclosure: 'low',
      insecureDependencies: 'medium',
      hardcodedSecrets: 'high'
    };
    
    return severityMap[category] || 'medium';
  }

  getDescription(category, match) {
    const descriptions = {
      sqlInjection: 'Potential SQL injection vulnerability detected',
      xss: 'Potential Cross-Site Scripting (XSS) vulnerability',
      authentication: 'Hardcoded authentication credentials detected',
      cryptography: 'Weak cryptographic function usage',
      pathTraversal: 'Potential path traversal vulnerability',
      commandInjection: 'Potential command injection vulnerability',
      informationDisclosure: 'Information disclosure through logging',
      insecureDependencies: 'Potentially vulnerable dependency',
      hardcodedSecrets: 'Hardcoded secret or credential'
    };
    
    return descriptions[category] || 'Security issue detected';
  }

  getRecommendation(category) {
    const recommendations = {
      sqlInjection: 'Use parameterized queries or ORM methods',
      xss: 'Sanitize user input and use proper encoding',
      authentication: 'Use environment variables for credentials',
      cryptography: 'Use strong cryptographic functions (SHA-256, bcrypt)',
      pathTraversal: 'Validate and sanitize file paths',
      commandInjection: 'Avoid executing user input as commands',
      informationDisclosure: 'Remove debug logging from production code',
      insecureDependencies: 'Update to secure versions of dependencies',
      hardcodedSecrets: 'Use environment variables or secure vaults'
    };
    
    return recommendations[category] || 'Review and fix security issue';
  }

  generateScanReport() {
    const severityCounts = {
      critical: this.vulnerabilities.filter(v => v.severity === 'critical').length,
      high: this.vulnerabilities.filter(v => v.severity === 'high').length,
      medium: this.vulnerabilities.filter(v => v.severity === 'medium').length,
      low: this.vulnerabilities.filter(v => v.severity === 'low').length
    };

    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        scannedFiles: this.scannedFiles,
        totalVulnerabilities: this.vulnerabilities.length,
        severityCounts
      },
      vulnerabilities: this.vulnerabilities,
      riskScore: this.calculateRiskScore(severityCounts),
      recommendations: this.generateRecommendations()
    };

    return report;
  }

  calculateRiskScore(severityCounts) {
    const weights = { critical: 10, high: 7, medium: 4, low: 1 };
    const score = Object.entries(severityCounts)
      .reduce((total, [severity, count]) => total + (weights[severity] * count), 0);
    
    return {
      score,
      level: score === 0 ? 'Low' : score < 20 ? 'Medium' : score < 50 ? 'High' : 'Critical'
    };
  }

  generateRecommendations() {
    const recommendations = [
      'Implement automated security scanning in CI/CD pipeline',
      'Regular security code reviews',
      'Keep dependencies updated',
      'Use security linting tools (ESLint security plugins)',
      'Implement proper input validation and sanitization',
      'Use environment variables for sensitive configuration',
      'Regular penetration testing',
      'Security training for development team'
    ];

    return recommendations;
  }
}

module.exports = VulnerabilityScanner;